name: 'Portainer API Action'
description: 'Deploy and manage Docker containers and stacks via Portainer API'
author: 'bignellrp'

branding:
  icon: 'upload-cloud'
  color: 'blue'

inputs:
  portainer_url:
    description: 'Portainer instance URL (e.g., https://portainer.example.com)'
    required: true
  portainer_api_key:
    description: 'Portainer API access token'
    required: true
  stack_name:
    description: 'Name of the stack to deploy/update'
    required: true
    default: "${GITHUB_REPOSITORY#*/}"
  stack_file:
    description: 'Path to docker-compose stack file'
    required: false
    default: 'docker-compose.yml'
  endpoint_id:
    description: 'Portainer endpoint ID'
    required: false
    default: '1'
  action:
    description: 'Action to perform: deploy, update, or redeploy'
    required: false
    default: 'redeploy'
  env_vars:
    description: 'Environment variables as JSON string (e.g., {"KEY": "value"})'
    required: false
    default: '{}'
  prune:
    description: 'Prune services not defined in the stack file'
    required: false
    default: 'true'

outputs:
  stack_id:
    description: 'ID of the deployed/updated stack'
    value: ${{ steps.portainer-deploy.outputs.stack_id }}
  status:
    description: 'Status of the operation'
    value: ${{ steps.portainer-deploy.outputs.status }}

runs:
  using: 'composite'
  steps:
    - name: Deploy to Portainer
      id: portainer-deploy
      shell: bash
      run: |
        echo "::group::Portainer API Deployment"

        request_json() {
          local method="$1"
          local url="$2"
          local payload="${3-}"

          local response
          if [ -n "${payload}" ]; then
            response=$(curl -sS -w "\n%{http_code}" -X "$method" \
              -H "X-API-Key: $PORTAINER_API_KEY" \
              -H "Content-Type: application/json" \
              -d "$payload" \
              "$url")
          else
            response=$(curl -sS -w "\n%{http_code}" -X "$method" \
              -H "X-API-Key: $PORTAINER_API_KEY" \
              "$url")
          fi

          local body="${response%$'\n'*}"
          local code="${response##*$'\n'}"

          if [ -z "$code" ] || ! echo "$code" | grep -Eq '^[0-9]{3}$'; then
            echo "::error::Failed to parse HTTP status code from response"
            echo "$response"
            return 1
          fi

          if [ "$code" -lt 200 ] || [ "$code" -ge 300 ]; then
            echo "::error::Portainer API request failed ($method $url)"
            echo "::error::HTTP $code"
            if [ -n "$body" ]; then
              echo "::error::Response body: $body"
            fi
            return 22
          fi

          echo "$body"
        }

        # Set variables
        PORTAINER_URL="${{ inputs.portainer_url }}"
        PORTAINER_API_KEY="${{ inputs.portainer_api_key }}"
        STACK_NAME="${{ inputs.stack_name }}"
        STACK_FILE="${{ inputs.stack_file }}"
        ENDPOINT_ID="${{ inputs.endpoint_id }}"
        ACTION="${{ inputs.action }}"
        ENV_VARS='${{ inputs.env_vars }}'
        PRUNE="${{ inputs.prune }}"

        # Remove trailing slash from URL
        PORTAINER_URL="${PORTAINER_URL%/}"

        echo "Stack Name: $STACK_NAME"
        echo "Stack File: $STACK_FILE"
        echo "Endpoint ID: $ENDPOINT_ID"
        echo "Action: $ACTION"

        # Validate stack file exists
        if [ ! -f "$STACK_FILE" ]; then
          echo "::error::Stack file not found: $STACK_FILE"
          exit 1
        fi

        # Read stack file content
        STACK_CONTENT=$(cat "$STACK_FILE")

        # Check if stack exists
        echo "Checking if stack exists..."
        STACKS_RESPONSE=$(request_json GET "$PORTAINER_URL/api/stacks")

        STACK_ID=$(echo "$STACKS_RESPONSE" | jq -r ".[] | select(.Name == \"$STACK_NAME\") | .Id // empty")

        if [ -z "$STACK_ID" ]; then
          echo "Stack does not exist. Creating new stack..."

          # Create payload for new stack
          PAYLOAD=$(jq -n \
            --arg name "$STACK_NAME" \
            --arg content "$STACK_CONTENT" \
            --argjson endpoint "$ENDPOINT_ID" \
            --argjson env "$ENV_VARS" \
            '{
              Name: $name,
              StackFileContent: $content,
              Env: ($env | to_entries | map({name: .key, value: .value}))
            }')

          # Create stack
          CREATE_RESPONSE=$(request_json POST "$PORTAINER_URL/api/stacks/create/swarm/string?endpointId=$ENDPOINT_ID" "$PAYLOAD")

          STACK_ID=$(echo "$CREATE_RESPONSE" | jq -r '.Id // empty')

          if [ -z "$STACK_ID" ]; then
            echo "::error::Failed to create stack. Response: $CREATE_RESPONSE"
            exit 1
          fi

          echo "Stack created successfully with ID: $STACK_ID"
          echo "stack_id=$STACK_ID" >> $GITHUB_OUTPUT
          echo "status=created" >> $GITHUB_OUTPUT

        else
          echo "Stack exists with ID: $STACK_ID"

          if [ "$ACTION" = "redeploy" ]; then
            echo "Redeploying stack..."

            # Update stack with pull image flag
            PAYLOAD=$(jq -n \
              --arg content "$STACK_CONTENT" \
              --argjson env "$ENV_VARS" \
              --argjson prune "$PRUNE" \
              '{
                StackFileContent: $content,
                Env: ($env | to_entries | map({name: .key, value: .value})),
                Prune: $prune,
                PullImage: true
              }')

            UPDATE_RESPONSE=$(curl -sf -X PUT \
              -H "X-API-Key: $PORTAINER_API_KEY" \
              -H "Content-Type: application/json" \
              -d "$PAYLOAD" \
              "$PORTAINER_URL/api/stacks/$STACK_ID?endpointId=$ENDPOINT_ID" 2>/dev/null)

            UPDATE_RESPONSE=$(request_json PUT "$PORTAINER_URL/api/stacks/$STACK_ID?endpointId=$ENDPOINT_ID" "$PAYLOAD")

            UPDATED_ID=$(echo "$UPDATE_RESPONSE" | jq -r '.Id // empty')
            if [ -n "$UPDATED_ID" ]; then
              echo "Stack redeployed successfully"
              echo "stack_id=$STACK_ID" >> $GITHUB_OUTPUT
              echo "status=redeployed" >> $GITHUB_OUTPUT
            else
              echo "::error::Failed to redeploy stack. Response: $UPDATE_RESPONSE"
              exit 1
            fi

          else
            echo "Updating stack..."

            PAYLOAD=$(jq -n \
              --arg content "$STACK_CONTENT" \
              --argjson env "$ENV_VARS" \
              --argjson prune "$PRUNE" \
              '{
                StackFileContent: $content,
                Env: ($env | to_entries | map({name: .key, value: .value})),
                Prune: $prune
              }')

            UPDATE_RESPONSE=$(curl -sf -X PUT \
              -H "X-API-Key: $PORTAINER_API_KEY" \
              -H "Content-Type: application/json" \
              -d "$PAYLOAD" \
              "$PORTAINER_URL/api/stacks/$STACK_ID?endpointId=$ENDPOINT_ID" 2>/dev/null)

            UPDATE_RESPONSE=$(request_json PUT "$PORTAINER_URL/api/stacks/$STACK_ID?endpointId=$ENDPOINT_ID" "$PAYLOAD")

            UPDATED_ID=$(echo "$UPDATE_RESPONSE" | jq -r '.Id // empty')
            if [ -n "$UPDATED_ID" ]; then
              echo "Stack updated successfully"
              echo "stack_id=$STACK_ID" >> $GITHUB_OUTPUT
              echo "status=updated" >> $GITHUB_OUTPUT
            else
              echo "::error::Failed to update stack. Response: $UPDATE_RESPONSE"
              exit 1
            fi
          fi
        fi

        echo "::endgroup::"
