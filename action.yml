name: 'Portainer API Action'
description: 'Deploy and manage Docker containers and stacks via Portainer API'
author: 'bignellrp'

branding:
  icon: 'upload-cloud'
  color: 'blue'

inputs:
  portainer_url:
    description: 'Portainer instance URL (e.g., https://portainer.example.com)'
    required: true
  portainer_api_key:
    description: 'Portainer API access token'
    required: true
  stack_name:
    description: 'Name of the stack to deploy/update'
    required: true
    default: "${GITHUB_REPOSITORY#*/}"
  stack_file:
    description: 'Path to docker-compose stack file'
    required: false
    default: 'docker-compose.yml'
  endpoint_id:
    description: 'Portainer endpoint ID'
    required: false
    default: '2'
  stack_type:
    description: 'Portainer stack type (2 = Compose, 1 = Swarm)'
    required: false
    default: '2'
  action:
    description: 'Action to perform: deploy, update, or redeploy'
    required: false
    default: 'redeploy'
  env_vars:
    description: 'Environment variables as JSON string (e.g., {"KEY": "value"})'
    required: false
    default: '{}'
  prune:
    description: 'Prune services not defined in the stack file'
    required: false
    default: 'true'
  x_registry_auth:
    description: 'Optional X-Registry-Auth header value (base64). Useful for private registries.'
    required: false
    default: ''
  registry_match:
    description: 'Optional regex to auto-select a Portainer registry (matches Name or URL). Sets X-Registry-Auth if found.'
    required: false
    default: ''

outputs:
  stack_id:
    description: 'ID of the deployed/updated stack'
    value: ${{ steps.portainer-deploy.outputs.stack_id }}
  status:
    description: 'Status of the operation'
    value: ${{ steps.portainer-deploy.outputs.status }}

runs:
  using: 'composite'
  steps:
    - name: Deploy to Portainer
      id: portainer-deploy
      shell: bash
      run: |
        echo "::group::Portainer API Deployment"

        request_json() {
          local method="$1"
          local url="$2"
          local payload="${3-}"

          local curl_args=(-sS -w "\n%{http_code}" -X "$method" -H "X-API-Key: $PORTAINER_API_KEY")
          if [ -n "${X_REGISTRY_AUTH:-}" ]; then
            curl_args+=(-H "X-Registry-Auth: $X_REGISTRY_AUTH")
          fi
          if [ -n "${payload}" ]; then
            curl_args+=(-H "Content-Type: application/json" -d "$payload")
          fi

          local response
          response=$(curl "${curl_args[@]}" "$url")

          local body="${response%$'\n'*}"
          local code="${response##*$'\n'}"

          if [ -z "$code" ] || ! echo "$code" | grep -Eq '^[0-9]{3}$'; then
            echo "::error::Failed to parse HTTP status code from response"
            echo "$response"
            return 1
          fi

          if [ "$code" -lt 200 ] || [ "$code" -ge 300 ]; then
            echo "::error::Portainer API request failed ($method $url)"
            echo "::error::HTTP $code"
            if [ -n "$body" ]; then
              echo "::error::Response body: $body"
            fi
            return 22
          fi

          echo "$body"
        }

        # Like request_json, but returns two lines:
        #   line1: HTTP status code
        #   line2+: response body (may be empty)
        request_json_raw() {
          local method="$1"
          local url="$2"
          local payload="${3-}"

          local curl_args=(-sS -w "\n%{http_code}" -X "$method" -H "X-API-Key: $PORTAINER_API_KEY")
          if [ -n "${X_REGISTRY_AUTH:-}" ]; then
            curl_args+=(-H "X-Registry-Auth: $X_REGISTRY_AUTH")
          fi
          if [ -n "${payload}" ]; then
            curl_args+=(-H "Content-Type: application/json" -d "$payload")
          fi

          curl "${curl_args[@]}" "$url"
        }

        # Set variables
        PORTAINER_URL="${{ inputs.portainer_url }}"
        PORTAINER_API_KEY="${{ inputs.portainer_api_key }}"
        STACK_NAME="${{ inputs.stack_name }}"
        STACK_FILE="${{ inputs.stack_file }}"
        ENDPOINT_ID="${{ inputs.endpoint_id }}"
        STACK_TYPE="${{ inputs.stack_type }}"
        ACTION="${{ inputs.action }}"
        ENV_VARS='${{ inputs.env_vars }}'
        PRUNE="${{ inputs.prune }}"
        X_REGISTRY_AUTH_INPUT="${{ inputs.x_registry_auth }}"
        REGISTRY_MATCH="${{ inputs.registry_match }}"

        # Normalize URL to a base Portainer URL (tolerate full API URLs too)
        # Examples:
        # - https://portainer.example.com
        # - https://portainer.example.com/api/stacks?type=1
        base="${PORTAINER_URL%%\?*}"
        base="${base%/}"
        base="${base%%/api/*}"
        base="${base%%/api}"
        PORTAINER_URL="$base"

        echo "Stack Name: $STACK_NAME"
        echo "Stack File: $STACK_FILE"
        echo "Endpoint ID: $ENDPOINT_ID"
        echo "Stack Type: $STACK_TYPE"
        echo "Action: $ACTION"

        if ! command -v jq >/dev/null 2>&1; then
          echo "::error::jq is required but was not found on PATH. Install jq in your workflow (e.g. apt-get install -y jq)."
          exit 1
        fi

        if ! echo "$ENV_VARS" | jq -e . >/dev/null 2>&1; then
          echo "::error::env_vars must be valid JSON"
          exit 1
        fi
        if [ "$(echo "$ENV_VARS" | jq -r 'type')" != "object" ]; then
          echo "::error::env_vars must be a JSON object (e.g. {\"KEY\":\"value\"})"
          exit 1
        fi

        # Validate stack file exists
        if [ ! -f "$STACK_FILE" ]; then
          echo "::error::Stack file not found: $STACK_FILE"
          exit 1
        fi

        # Read stack file content
        STACK_CONTENT=$(cat "$STACK_FILE")

        if [ "$ACTION" = "redeploy" ]; then
          redeploy_token="${GITHUB_RUN_ID:-0}-${GITHUB_RUN_ATTEMPT:-0}-$(date +%s)"
          ENV_VARS=$(echo "$ENV_VARS" | jq -c --arg v "$redeploy_token" '. + {REDEPLOY_TS: $v}')
        fi

        # Optional registry auth for private registries
        X_REGISTRY_AUTH="${X_REGISTRY_AUTH_INPUT}"
        if [ -z "${X_REGISTRY_AUTH}" ] && [ -n "${REGISTRY_MATCH}" ]; then
          echo "Looking up registry matching: ${REGISTRY_MATCH}"
          REGISTRIES_RESPONSE=$(request_json GET "$PORTAINER_URL/api/registries") || exit $?
          REGISTRY_ID=$(echo "$REGISTRIES_RESPONSE" | jq -r --arg re "$REGISTRY_MATCH" '
            map(select((.URL // "" | test($re)) or (.Name // "" | test($re))))
            | (.[0].Id // .[0].ID // empty)
          ')

          if [ -n "${REGISTRY_ID}" ]; then
            X_REGISTRY_AUTH=$(printf '{"registryId":%s}' "$REGISTRY_ID" | base64 | tr -d '\n')
            echo "Using registryId=$REGISTRY_ID for X-Registry-Auth"
          else
            echo "No matching registry found in Portainer; proceeding without X-Registry-Auth"
          fi
        fi

        # Check if stack exists
        echo "Checking if stack exists..."
        STACKS_RESPONSE=$(request_json GET "$PORTAINER_URL/api/stacks") || exit $?

        STACK_ID=$(echo "$STACKS_RESPONSE" | jq -r \
          --arg name "$STACK_NAME" \
          --argjson endpoint "$ENDPOINT_ID" \
          '.[]
            | select(.Name == $name and ((.EndpointId // .EndpointID) == $endpoint))
            | (.Id // .ID // empty)' \
          | head -n 1)

        if [ -z "$STACK_ID" ]; then
          echo "Stack does not exist. Creating new stack..."

          # Create payload for new stack
          PAYLOAD=$(jq -n \
            --arg name "$STACK_NAME" \
            --arg content "$STACK_CONTENT" \
            --argjson env "$ENV_VARS" \
            '{
              Name: $name,
              StackFileContent: $content,
              Env: ($env | to_entries | map({name: .key, value: .value}))
            }')

          # Create stack
          # Portainer 2.33+ commonly uses the /api/stacks/create/standalone/string endpoint.
          # Older Portainer builds used POST /api/stacks?type=...&method=string&endpointId=...
          create_url_new="$PORTAINER_URL/api/stacks/create/standalone/string?endpointId=$ENDPOINT_ID"
          create_url_old="$PORTAINER_URL/api/stacks?type=$STACK_TYPE&method=string&endpointId=$ENDPOINT_ID"

          CREATE_RAW=$(request_json_raw POST "$create_url_new" "$PAYLOAD") || exit $?
          CREATE_BODY="${CREATE_RAW%$'\n'*}"
          CREATE_CODE="${CREATE_RAW##*$'\n'}"

          if [ "$CREATE_CODE" = "404" ] || [ "$CREATE_CODE" = "405" ]; then
            echo "Create endpoint not supported ($CREATE_CODE). Falling back to legacy create route..."
            CREATE_RESPONSE=$(request_json POST "$create_url_old" "$PAYLOAD") || exit $?
          else
            if [ "$CREATE_CODE" -lt 200 ] || [ "$CREATE_CODE" -ge 300 ]; then
              echo "::error::Portainer API request failed (POST $create_url_new)"
              echo "::error::HTTP $CREATE_CODE"
              if [ -n "$CREATE_BODY" ]; then
                echo "::error::Response body: $CREATE_BODY"
              fi
              exit 22
            fi
            CREATE_RESPONSE="$CREATE_BODY"
          fi

          STACK_ID=$(echo "$CREATE_RESPONSE" | jq -r '.Id // .ID // .id // empty')

          if [ -z "$STACK_ID" ]; then
            echo "::error::Failed to create stack. Response: $CREATE_RESPONSE"
            exit 1
          fi

          echo "Stack created successfully with ID: $STACK_ID"
          echo "stack_id=$STACK_ID" >> $GITHUB_OUTPUT
          echo "status=created" >> $GITHUB_OUTPUT

        else
          echo "Stack exists with ID: $STACK_ID"

          if [ "$ACTION" = "redeploy" ]; then
            echo "Redeploying stack..."

            # Update stack with pull image flag
            PAYLOAD=$(jq -n \
              --arg content "$STACK_CONTENT" \
              --argjson env "$ENV_VARS" \
              --argjson prune "$PRUNE" \
              '{
                stackFileContent: $content,
                env: ($env | to_entries | map({name: .key, value: .value})),
                prune: $prune,
                pullImage: true
              }')

            UPDATE_RESPONSE=$(request_json PUT "$PORTAINER_URL/api/stacks/$STACK_ID?endpointId=$ENDPOINT_ID" "$PAYLOAD") || exit $?
            echo "Stack redeployed successfully"
            echo "stack_id=$STACK_ID" >> $GITHUB_OUTPUT
            echo "status=redeployed" >> $GITHUB_OUTPUT

          else
            echo "Updating stack..."

            PAYLOAD=$(jq -n \
              --arg content "$STACK_CONTENT" \
              --argjson env "$ENV_VARS" \
              --argjson prune "$PRUNE" \
              '{
                stackFileContent: $content,
                env: ($env | to_entries | map({name: .key, value: .value})),
                prune: $prune
              }')

            UPDATE_RESPONSE=$(request_json PUT "$PORTAINER_URL/api/stacks/$STACK_ID?endpointId=$ENDPOINT_ID" "$PAYLOAD") || exit $?
            echo "Stack updated successfully"
            echo "stack_id=$STACK_ID" >> $GITHUB_OUTPUT
            echo "status=updated" >> $GITHUB_OUTPUT
          fi
        fi

        echo "::endgroup::"
